// version 1 wallet
/* var data = {
        "auth_type": 0,
        "real_auth_type": 0,
        "symbol_local": {
                "symbol": "$",
                "code": "USD",
                "symbolAppearsAfter": false,
                "name": "U.S. dollar",
                "local": true,
                "conversion": 8740.20441590
        },
        "clientTimeDiff": 146,
        "war_checksum": "50ccf62acf245222",
        "language": "en",
        "symbol_btc": {
                "symbol": "BTC",
                "code": "BTC",
                "symbolAppearsAfter": true,
                "name": "Bitcoin",
                "local": false,
                "conversion": 100000000.00000000
        },
        "extra_seed": "97512381757d660cd4d5e1f5db0afd149bb9c936b77db6e3cbdfdc73f1e4b322d568e133a10ecf8d5c71a6fbede77cf76130a2cbd782ac623b6f513410f45c90",
        "payload": "RjiBQTrAxYWYFdCKAMIq+ztdt2w2bswy0+WBJjtrMY3iBx3H2I8nAyWhwJdKv7Jb6uxWpTbyr5XssqFAsUkKAsRAgHi8uUbz\/6ilapG7YnG0hhVQ1ZSSKoj3vDMY4uUXBff0dqfNkDgKEc2ubOua+YLfDR\/bME2H13JXSD\/Dj2mewv\/+I9Z2hi2BVARiVq5H65MGK+u8uV0\/aZffj4OXlQdx2JUl\/bpouMPBP2YWAh\/r6oO8Ed6w6jkwQ+zc\/+qGfCWEtTWIkOffz+I+q+ikJKdXOd6AaSobA2KWcRzsa3dDWLpT3PLPXDliu+hisGPvNVvHPFA0GY0K8+Pofove6iof0NdeFhkydWaa+a1aOHnmJc9nHh6aDGpr9vPAFf4GRuCEbXsXk9iVS58fRh\/LqyNgWyO6kHQQbJPOWJZ3grrIyJ7Uo7JjQRvUbDKT64Y9A7cw34Rpvi7exn9FwLtwTw==",
        "guid": "e7de31af-43f6-4201-b9de-740eefa9d80a",
        "serverTime": 1513954300510,
        "payload_checksum": "6f4dc6b7898148d910b722ffac56e374a3b059503bbbcac413e4d9f37c5b20f8",
        "sync_pubkeys": true
} */
// version 3 wallet
var data = {
        "auth_type": 0,
        "real_auth_type": 0,
        "symbol_local": {
                "symbol": "$",
                "code": "USD",
                "symbolAppearsAfter": false,
                "name": "U.S. dollar",
                "local": true,
                "conversion": 8304.63390267
        },
        "clientTimeDiff": 153,
        "war_checksum": "50ccf62acf245222",
        "language": "en",
        "symbol_btc": {
                "symbol": "BTC",
                "code": "BTC",
                "symbolAppearsAfter": true,
                "name": "Bitcoin",
                "local": false,
                "conversion": 100000000.00000000
        },
        "extra_seed": "a815b8bc847e838188a07d7287ca8863ecfaed5cd445971eaa58e2eede569a0f9c612e05cd47e60dc6776f9c646146ae5485143cabe3ea8d567dc4c1d82bb917",
        "payload": "{\"pbkdf2_iterations\":5000,\"version\":3,\"payload\":\"9tWCD0YA3dkpbsecSaHWZd7cgGRoUQV7qHoHSBSz3GlTlpUP7Ir3LTgJSxcVzY\/O5ejYuK9iVp3C3xkSuvDyacaZEZh+DRHvZludC0+W+icNxNxuR+W1qsxRb31sHq7MRdRrppwoZkHT\/vG3fo6KGCHnfKxxDRGvkLcAnQbL5duSoALSJkyDNP6LE6sQpROH9PXlBb4TaQ1IjZbQ7jn2gQcxveA4L5199SyeFP6C6qpnM0xWgptIOAOj4vs5Pw8AwLp6fNivJrqNQTYkG0ACMoYggm9LSFGpRKysQB54+wKN2B0BhBARLt\/uKuOu2Ocvu8299K4lqva6h40izq018AZkULv2x3hJV9yyvNFRzk0lBRShuI77Kn9p9wqKzBILiPZpp\/7MAGCxY7dLbzn\/sSZonrTrKwZHsIXSGzJRot\/HLuAG0Tw9aDYh8HioZh+z+m4d\/LB8FHGSBFu+py6N9yoWyq9qWVGN8Jv6UzQyUivbSZahDbqS7Bqjiqys04xkkkNdrcoQduRGtmTyOA\/XeQDXiY+HeqT1ajcsKS4Tx7SDKpuspmBT+Py1Gl+iRPSv1mw3DSGAa+7mAJeLEpYGxKDMsOnFjWvY4oMiiDtO+bpK7Br5DdkpSBlX7zsxsstJ5xHKnyxwT6IlRe4IwAlAfirGr5Yu3cOEhHKzlJuB1sU25+THupT1eXKgBKosLyz9W8u9CyxpgnNnW\/AslIFXB77lwO0iPejQHisiyHqSbHKki+3+8Q9mf5QSxmRB2wATkV3Uj3BnmqGw2NyF4HTP\/29PJ6gX70q7MoO+50oPTrCu793E5deawJPG2NaM9xQZXY6JebxPIhS3Xdmr2PNUBUhJVdx83poN6UmQQJVccwZX70XEldEMzHVLiOo7\/pLf1nrNp\/WD+ShnNYeU7dNihZw7G0XQnmfdgY6tVuxrFgdNxKu4keLdk4u3JFgS54NOWLobLyXbA+jKZPkMkQBjtZ1Z\/wHb4TnK6HoSHzqGDR59U+kQEJRgmQOpLf3FFiCWQerMl8BSuYhdfxDcTBC9FeBC1fEbG\/oFdXFcL9W0GS9OMDo60NVfThWdAWameB1BTbwLPjla0eA4Zkdk2EtTwgLPyTu7movXeUpkkEXGz3uJA2xylkfPM\/ux3Hcx5oa66WgOE62d\/KuGKEeOZdDcUGFwowOUEuc0TotupuHgJwBs23WwiSF+9QJ6kqUv8C+aN3OMpyWYJwJZygDOHb7gSRaCHm7wx9MgYI9hSdN7Wg183gedFU5iaSjw1DeygTkjcBAMmLuqw+dqi69WJVMSlXMGlJwKerJtr68+K6OhDMwKMa\/0Qzypki4pX8VHDajI5cgzTlaIO6l0j2bVrxJzxXEIhGfZsf09aRbXEV4ripVhOxL++iCAsF6USkKKLoFuwZQmZWT+eVIhS5OksSG+qJ7piFkOMyCCNaA\/7qCXkSny0uV6JzqZrffBV\/tH8FTjAYlqebD1zhJtvWk357SaD675FSw5HOokioNtFa+uOaSae9KvEQsOySwNMIk66+Yc4ZjXTg83CCpexmNRlhBHiHK3ExcrQj1oa2ZuEcGlHAQjEg0BvTVlb3mK47SGoMLWYZnTu5uK6rTw8aesNqf9vRfsHfz8xax1yEs\/fL9QBEo8G0TKdud+AMq24JRUH\/jyQzGIRltdde87XdVz7sQcHl7e+QEfgyN3ssHaCG7ZmHUSIUshdS8TiisGXbPLJ7vNXwixKVIEovh++7uZvDY4Fe8P4KNYKs7iPe5l9YgSC0SMeIe4M3CWTVFm4FdkStPi1o4hP6Z0Xpwcc\/Ra7SjgET\/dljB3nSD45bpkvnwNHZDrV3KrDjf3AKmeurqpj3\/Fhk+rxJp9itoQc2kbAol9g\/O8RGcfUvRyJ+wKZ139jtY=\"}",
        "guid": "e746710b-ca3a-4d4c-92e8-4fc933ffd42e",
        "serverTime": 1513954922783,
        "payload_checksum": "6e97c996538ffdcacc8aa8694c9755662737b9b2b01a5bbbdb1cc99ee68e9416",
        "sync_pubkeys": false
}

var pbkdf2 = require('pbkdf2');
var crypto = require('crypto');
const fs = require('fs');


var SUPPORTED_ENCRYPTION_VERSION = 3;
var SALT_BYTES = 16;
var KEY_BIT_LEN = 256;
var ALGO = {
        SHA1: "sha1",
        SHA256: "sha256"
};
var NoPadding = {
        pad: function pad(dataBytes) {
                return dataBytes;
        },
        unpad: function unpad(dataBytes) {
                return dataBytes;
        }
};
var Iso10126 = {
        pad: function pad(dataBytes, nBytesPerBlock) {
                var nPaddingBytes = nBytesPerBlock - dataBytes.length % nBytesPerBlock;
                var paddingBytes = crypto.randomBytes(nPaddingBytes - 1);
                var endByte = new Buffer([nPaddingBytes]);
                return Buffer.concat([dataBytes, paddingBytes, endByte])
        },
        unpad: function unpad(dataBytes) {
                var nPaddingBytes = dataBytes[dataBytes.length - 1];
                return dataBytes.slice(0, -nPaddingBytes)
        }
};

var Iso97971 = {
        pad: function pad(dataBytes, nBytesPerBlock) {
                var withStartByte = Buffer.concat([dataBytes, new Buffer([128])]);
                return ZeroPadding.pad(withStartByte, nBytesPerBlock)
        },
        unpad: function unpad(dataBytes) {
                var zeroBytesRemoved = ZeroPadding.unpad(dataBytes);
                return zeroBytesRemoved.slice(0, zeroBytesRemoved.length - 1)
        }
};

var AES = {
        CBC: "aes-256-cbc",
        OFB: "aes-256-ofb",
        ECB: "aes-256-ecb",
        encrypt: function encrypt(dataBytes, key, salt, options) {
                options = options || {};
                assert(Buffer.isBuffer(dataBytes), "expected `dataBytes` to be a Buffer");
                assert(Buffer.isBuffer(key), "expected `key` to be a Buffer");
                assert(Buffer.isBuffer(salt) || salt === null, "expected `salt` to be a Buffer or null");
                var cipher = crypto.createCipheriv(options.mode || AES.CBC, key, salt || "");
                cipher.setAutoPadding(!options.padding);
                if (options.padding)
                        dataBytes = options.padding.pad(dataBytes, BLOCK_BIT_LEN / 8);
                var encryptedBytes = Buffer.concat([cipher.update(dataBytes), cipher.final()]);
                return encryptedBytes;
        },
        decrypt: function decrypt(dataBytes, key, salt, options) {
                options = options || {};
                var decipher;
                try {
                        decipher = crypto.createDecipheriv(options.mode || AES.CBC, key, salt || "");
                } catch (e) {
                        //console.log(e);
                }
                decipher.setAutoPadding(!options.padding);
                var decryptedBytes = Buffer.concat([decipher.update(dataBytes), decipher.final()]);
                if (options.padding)
                        decryptedBytes = options.padding.unpad(decryptedBytes);
                return decryptedBytes;
        }
};

function pbkdf2f__(password, salt, iterations, keyLenBytes, algorithm) {
        algorithm = algorithm || ALGO.SHA1;
        var result;
        try {
                result = pbkdf2.pbkdf2Sync(password, salt, iterations, keyLenBytes, algorithm);
        } catch (e) {
                //console.log(e);
        }
        return result;
}

function decryptBufferWithKey(payload, iv, key, options) {
        options = options || {};
        options.padding = options.padding || Iso10126;
        var decryptedBytes = AES.decrypt(payload, key, iv, options);
        return decryptedBytes.toString("utf8")
}

function decryptDataWithPassword(data, password, iterations, options) {
        var res;
        try {
                var dataHex = new Buffer(data, "base64");
                var iv = dataHex.slice(0, SALT_BYTES);
                var payload = dataHex.slice(SALT_BYTES);
                var salt = iv;
                var key = stretchPassword(password, salt, iterations, KEY_BIT_LEN);
                res = decryptBufferWithKey(payload, iv, key, options);
        } catch (e) {
                //console.log(e);
        }
        return res;
}

function stretchPassword(password, salt, iterations, keyLenBits) {
        var saltBuffer = new Buffer(salt, "hex");
        var keyLenBytes = (keyLenBits || 256) / 8;
        var result;
        try {
                result = pbkdf2f__(password, saltBuffer, iterations, keyLenBytes, ALGO.SHA1);
        } catch (e) {
                //console.log(e);
        }
        return result;
}

function decryptWalletV1(data, password) {
        try {
                var decryptFns = [decryptDataWithPassword.bind(null, data, password, 10), decryptDataWithPassword.bind(null, data, password, 1, {
                        mode: AES.OFB,
                        padding: NoPadding
                }), decryptDataWithPassword.bind(null, data, password, 1, {
                        mode: AES.OFB,
                        padding: Iso97971
                }), decryptDataWithPassword.bind(null, data, password, 1, {
                        mode: AES.CBC,
                        padding: Iso10126
                })];
                return decryptFns.reduce(function (acc, decrypt) {
                        if (acc)
                                return acc;
                        try {
                                return JSON.parse(decrypt());
                        } catch (e) {
                                //console.log(e);
                                return null;
                        }
                }, null);
        } catch (e) {
                //console.log(e);
        }
}

function decryptWalletSync(data, password) {
        var wrapper, version, decrypted;
        try {
                wrapper = JSON.parse(data.payload);
        } catch (e) {
                console.log("decryptWalletSync version 1");
                version = 1;
        }
        if (wrapper) {
                version = wrapper.version;
        }
        if (version > SUPPORTED_ENCRYPTION_VERSION) {
                throw new Error("Wallet version " + version + " not supported.")
        }
        try {
                decrypted = decryptDataWithPassword(wrapper.payload, password, wrapper.pbkdf2_iterations);
                decrypted = JSON.parse(decrypted)
        } catch (e) {
                decrypted = decryptWalletV1(data, password);
                //console.log("Error decrypting wallet, please check that your password is correct");
        } finally {
                return decrypted;
        }
}

function initLimits(strings) {
        var limits = [];
        var i = 0;
        strings.forEach(function (s) {
                limits[i] = s.length;
                i++;
        });
        return limits;
}

function initCurrent(strings) {
        var limits = [];
        var i = 0;
        strings.forEach(function (s) {
                limits[i] = 0;
                i++;
        });
        return limits;
}

var counter = 0;
var found = false;

// I think my password is LittleMermaid
//var passswordAlphabet = ["Ll", "i", "t", "t", "l", "e", "Mm", "e", "r", "m", "a", "i", "d"];
var passswordAlphabet = ["P","i","t","n","e","y","7","7","o@"];

var limits = initLimits(passswordAlphabet);
var current = initCurrent(passswordAlphabet);

var done = false;
fs.appendFile('tested.txt', Date() + ' - ', (err) => {
        if (err) throw err;
});

/*
 * This part calls decrypt wallet repeatedly with possible passwords
 */

while (!done) {
        var password = "";
        for (var i = 0; i < limits.length; i++) {
                var c = passswordAlphabet[i].slice(current[i], current[i] + 1);
                if (c === "=") {

                        //password += strings[i].slice(current[i], current[i]+1);
                } else {
                        password += passswordAlphabet[i].slice(current[i], current[i] + 1);
                }
        }

        counter++;

        var decrypted = decryptWalletSync(data, password);
        if (decrypted != undefined) {
                found = true;
                fs.writeFile('password.txt', password, (err) => {
                        if (err) throw err;
                        console.log('Password found');
                });
        }
        //Incrementing for the next iteration
        for (var j = 0; j < limits.length; j++) {
                current[j]++;
                if (current[j] < limits[j]) {
                        break;
                }
                current[j] = 0;
                if (j == limits.length - 1) {
                        done = true;
                }
        }
}


fs.appendFile('tested.txt', Date() + ' : ' + passswordAlphabet + ' (' + counter + ') ' + '\n', (err) => {
        if (err) throw err;
});
